void startSampling(int freq)
{
    // the value of timer divirder
    int div = 80000000 / freq;
    
    // configer the timer
    timer_config_t timerConfig;
    // auto-reload the timer = resets the timer when the counter is reached
    timerConfig.auto_reload = TIMER_AUTORELOAD_EN;
    // enable the alarm
    timerConfig.alarm_en = TIMER_ALARM_EN;
    // timer is stopped
    timerConfig.counter_en = TIMER_PAUSE;
    // timer counts up
    timerConfig.counter_dir = TIMER_COUNT_UP;
    // divisor of the incoming 80 MHz APB_CLK clock
    // max is 65536
    timerConfig.divider = div;
    // timer interrupt level
    timerConfig.intr_type = TIMER_INTR_LEVEL;
    timer_init(TIMER_GROUP_0, TIMER_0, &timerConfig);
    // set the initial value of the counter to 0
    timer_set_counter_value(TIMER_GROUP_0, TIMER_0, 0x00000000ULL);
    // using a compare register of 1, the alarm should be raised at 1 of the passed frq
    timer_set_alarm_value(TIMER_GROUP_0, TIMER_0, 1);
    // enable interrupts
    timer_enable_intr(TIMER_GROUP_0, TIMER_0);
    // register the ISR
    timer_isr_register(TIMER_GROUP_0, TIMER_0, timerISR, NULL, ESP_INTR_FLAG_IRAM, NULL);
    // starttimer
    timer_start(TIMER_GROUP_0, TIMER_0);

    // start ADC
    adc_power_on();
    // configure pin
    adc_gpio_init(ADC_UNIT_1, ADC1_GPIO32_CHANNEL);
    // use full 12 bits width
    adc1_config_width(ADC_WIDTH_BIT_12);
    // set attenuation (ADC_ATTEN_DB_11) to support full scale voltage
    adc1_config_channel_atten(ADC1_GPIO32_CHANNEL, ADC_ATTEN_DB_11);
    // set pin 34 pullup
    gpio_pullup_en(32);
    //restart the sound value
    crossingCounter = 0;
    //get the time when sampling start
    startsampleTime = esp_timer_get_time();
}